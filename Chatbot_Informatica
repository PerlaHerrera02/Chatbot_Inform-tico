import nltk
import json
import random
import numpy as np
import tensorflow as tf
from nltk.stem import SnowballStemmer
import pickle
import os
import re
import datetime
import ipywidgets as widgets
from IPython.display import display, HTML, Javascript
import time
from google.colab import drive

# -----------------------------------------------------------------------------
# Configuraci칩n inicial para Google Colab y NLTK
# -----------------------------------------------------------------------------

# Montar Google Drive
try:
    drive.mount('/content/drive')
    print("Google Drive montado correctamente.")
except Exception as e:
    print(f"Error al montar Google Drive: {e}")

# Definir la ruta base para guardar y cargar archivos en Google Drive
# Aseg칰rate de que esta carpeta exista en tu Drive
FILES_PATH = '/content/drive/MyDrive/Colab Notebooks/ArchivosIA/informatica_chat' # Cambia esto a tu ruta deseada

# Crear la carpeta si no existe
os.makedirs(FILES_PATH, exist_ok=True)
print(f"Carpeta de archivos asegurada en: {FILES_PATH}")

# Descargar recursos de NLTK
# Esto es CRUCIAL para evitar LookupError
try:
    nltk.data.path.append(FILES_PATH) # A침adir la ruta de Drive a los Paths de NLTK
    # Intentar cargar 'punkt' para espa침ol. Si falla, intentar descargar.
    try:
        nltk.data.find('tokenizers/punkt/spanish.pickle')
        print("Recurso 'punkt' (espa침ol) ya descargado.")
    except LookupError:
        print("Descargando recurso 'punkt' (espa침ol)...")
        nltk.download('punkt', download_dir=FILES_PATH)
        print("Recurso 'punkt' (espa침ol) descargado exitosamente.")
except Exception as e:
    print(f"Error al descargar o verificar recursos de NLTK: {e}")
    print("El chatbot podr칤a usar un tokenizador menos preciso o fallar.")


# -----------------------------------------------------------------------------
# Definici칩n de los Intents (Ejemplo para Ingenier칤a en Inform치tica)
# -----------------------------------------------------------------------------

ejemplo_intents_informatica = """
{
    "intents": [
        {
            "tag": "bienvenida",
            "patterns": ["Hola", "Saludos", "Buenas", "쯈u칠 tal?", "Hola bot", "Ola", "Hi", "hola", "Estoy aqu칤", "Qu칠 onda"],
            "responses": [
                "춰Hola! Soy el bot de Ingenier칤a en Inform치tica 游뱄游눹 Estoy aqu칤 para responder tus preguntas sobre la carrera. 쯈u칠 te gustar칤a saber?",
                "춰Bienvenido/a! Soy tu asistente virtual para la carrera de Ingenier칤a en Inform치tica. 쮼n qu칠 puedo ayudarte hoy?",
                "춰Hola! 쯊ienes alguna pregunta sobre la Ingenier칤a en Inform치tica?"
            ]
        },
        {
            "tag": "nombre_carrera",
            "patterns": [
                "쮺칩mo se llama la carrera?",
                "쮺u치l es el nombre completo de la carrera?",
                "Nombre de la carrera",
                "Ingenier칤a en Inform치tica",
                "Sobre la carrera",
                "Quiero saber de la carrera"
            ],
            "responses": [
                "La carrera se llama Ingenier칤a en Inform치tica.",
                "Es la carrera de Ingenier칤a en Inform치tica.",
                "El nombre completo es Ingenier칤a en Inform치tica."
            ]
        },
        {
            "tag": "duracion_carrera",
            "patterns": [
                "쮺u치nto dura la carrera?",
                "Duraci칩n de la carrera",
                "A침os de estudio",
                "Tiempo de la carrera",
                "쮼n cu치ntos a침os se termina?"
            ],
            "responses": [
                "La duraci칩n de la carrera de Ingenier칤a en Inform치tica es de aproximadamente 5 a침os (10 semestres).",
                "Se completa en 10 semestres, lo que equivale a 5 a침os de estudio.",
                "Generalmente, la carrera dura 5 a침os."
            ]
        },
        {
            "tag": "salida_laboral",
            "patterns": [
                "쮼n qu칠 puedo trabajar?",
                "Salida laboral",
                "Campo laboral",
                "쮻칩nde trabaja un Ingeniero Inform치tico?",
                "Oportunidades de empleo",
                "쯈u칠 trabajos puedo hacer?"
            ],
            "responses": [
                "Un Ingeniero en Inform치tica tiene una amplia salida laboral: desarrollo de software (web, m칩vil, escritorio), inteligencia artificial, ciencia de datos, ciberseguridad, administraci칩n de redes y sistemas, consultor칤a tecnol칩gica, gesti칩n de proyectos de TI, desarrollo de videojuegos, entre otros.",
                "Podr치s trabajar en empresas de tecnolog칤a, startups, bancos, organismos gubernamentales, o emprender tu propio negocio.",
                "El campo laboral es muy din치mico y en constante crecimiento, ofreciendo roles como desarrollador, analista de datos, experto en ciberseguridad, arquitecto de software, etc."
            ]
        },
        {
            "tag": "plan_estudios",
            "patterns": [
                "쮺u치l es el plan de estudios?",
                "Materias de la carrera",
                "Asignaturas de Inform치tica",
                "쯈u칠 se estudia en Ingenier칤a Inform치tica?",
                "Malla curricular"
            ],
            "responses": [
                "El plan de estudios de Ingenier칤a en Inform치tica incluye materias como Programaci칩n (Python, Java, C++), Estructuras de Datos, Algoritmos, Bases de Datos, Redes de Computadoras, Sistemas Operativos, Ingenier칤a de Software, Inteligencia Artificial, Ciberseguridad, y Matem치ticas aplicadas.",
                "Se abordan tanto fundamentos te칩ricos como aplicaciones pr치cticas en diversas 치reas de la inform치tica.",
                "Estudiar치s desde la l칩gica de programaci칩n hasta el desarrollo de sistemas complejos y la gesti칩n de proyectos tecnol칩gicos."
            ]
        },
        {
            "tag": "requisitos_ingreso",
            "patterns": [
                "쯈u칠 necesito para ingresar?",
                "Requisitos de admisi칩n",
                "쮺칩mo entro a la carrera?",
                "Admisi칩n a Inform치tica",
                "Inscripci칩n"
            ],
            "responses": [
                "Los requisitos de ingreso suelen incluir haber completado la educaci칩n secundaria, presentar la documentaci칩n solicitada (DNI, certificado de estudios), y en algunos casos, aprobar un examen de admisi칩n o curso de nivelaci칩n.",
                "Te recomiendo visitar el sitio web oficial de la universidad o contactar a la oficina de admisiones para obtener la informaci칩n m치s precisa y actualizada.",
                "Generalmente se pide el t칤tulo de bachiller, DNI y en ocasiones un examen de ingreso o un curso proped칠utico."
            ]
        },
        {
            "tag": "habilidades_necesarias",
            "patterns": [
                "쯈u칠 habilidades necesito?",
                "Habilidades para Inform치tica",
                "쯉oy bueno para esta carrera?",
                "Perfil del estudiante",
                "쯈u칠 aptitudes se requieren?"
            ],
            "responses": [
                "Para Ingenier칤a en Inform치tica son 칰tiles: pensamiento l칩gico, capacidad de resoluci칩n de problemas, creatividad, curiosidad por la tecnolog칤a, habilidad para el trabajo en equipo, y disciplina para el autoaprendizaje.",
                "No te preocupes si no tienes todo al principio; muchas de estas habilidades se desarrollan durante la carrera.",
                "La clave es la curiosidad y las ganas de aprender y crear con tecnolog칤a."
            ]
        },
        {
            "tag": "costo_matricula",
            "patterns": [
                "쮺u치nto cuesta la matr칤cula?",
                "Costo de la carrera",
                "Precio de la inscripci칩n",
                "Cuotas",
                "Valor de la matr칤cula"
            ],
            "responses": [
                "El costo de la matr칤cula y las cuotas var칤an seg칰n la universidad (p칰blica o privada) y el pa칤s. Es mejor consultar directamente en la secretar칤a acad칠mica de la instituci칩n de tu inter칠s.",
                "Algunas universidades ofrecen becas o ayudas econ칩micas. Te sugiero investigar estas opciones.",
                "La informaci칩n de costos es muy espec칤fica de cada universidad. Te recomiendo contactarlos directamente."
            ]
        },
        {
            "tag": "diferencia_sistemas",
            "patterns": [
                "쮺u치l es la diferencia con Ingenier칤a en Sistemas?",
                "Inform치tica vs. Sistemas",
                "Diferencia entre Inform치tica y Computaci칩n",
                "쮼s lo mismo Ingenier칤a en Inform치tica que Sistemas?"
            ],
            "responses": [
                "Aunque se solapan, Ingenier칤a en Inform치tica se enfoca m치s en el software, la programaci칩n y la gesti칩n de datos, mientras que Ingenier칤a en Sistemas a menudo abarca una visi칩n m치s amplia de la integraci칩n de sistemas (hardware, software, personas, procesos).",
                "Inform치tica suele profundizar en el desarrollo de aplicaciones y algoritmos, mientras Sistemas puede inclinarse m치s hacia la arquitectura empresarial y la gesti칩n de proyectos de TI complejos.",
                "En general, el inform치tico construye el software, el de sistemas lo integra en un ecosistema m치s amplio."
            ]
        },
        {
            "tag": "practicas_profesionales",
            "patterns": [
                "쮿ay pr치cticas profesionales?",
                "Pasant칤as",
                "Pr치cticas en empresas",
                "Experiencia laboral durante la carrera"
            ],
            "responses": [
                "S칤, muchas universidades requieren pr치cticas profesionales o pasant칤as como parte del plan de estudios. Esto te permite aplicar tus conocimientos en un entorno real y ganar experiencia.",
                "Las pr치cticas son una excelente oportunidad para conectar con la industria y potenciar tu empleabilidad.",
                "Normalmente, se realizan pr치cticas en empresas para que los estudiantes adquieran experiencia real."
            ]
        },
        {
            "tag": "investigacion",
            "patterns": [
                "쯉e hace investigaci칩n en la carrera?",
                "Proyectos de investigaci칩n",
                "Oportunidades de investigaci칩n",
                "Investigaci칩n en Inform치tica"
            ],
            "responses": [
                "S칤, hay oportunidades para participar en proyectos de investigaci칩n con profesores en 치reas como IA, procesamiento de lenguaje natural, visi칩n por computadora, rob칩tica, etc.",
                "Muchos estudiantes se involucran en proyectos de investigaci칩n como parte de sus trabajos finales o como asistentes de investigaci칩n.",
                "La investigaci칩n es un componente importante en la carrera, especialmente si te interesa la academia o la innovaci칩n."
            ]
        },
        {
            "tag": "plataformas_virtuales",
            "patterns": [
                "쯋san plataformas en l칤nea?",
                "쯈u칠 plataforma se usa?",
                "Clases en l칤nea",
                "Aula virtual"
            ],
            "responses": [
                "S칤, se usa una plataforma virtual para compartir materiales, tareas, clases grabadas y m치s. Algunas universidades usan Moodle, Classroom o plataformas propias.",
                "Es una herramienta muy 칰til para seguir el ritmo de las materias y mantenerte organizado."
            ]
        },
        {
            "tag": "metodologia_estudio",
            "patterns": [
                "쮺칩mo se ense침a la carrera?",
                "Metodolog칤a de ense침anza",
                "쮼s m치s pr치ctica o te칩rica?",
                "쮺칩mo son las clases?"
            ],
            "responses": [
                "La metodolog칤a es mixta: teor칤a + pr치ctica. Se desarrollan proyectos, tareas, actividades colaborativas y resoluci칩n de problemas reales.",
                "El aprendizaje se basa en competencias, buscando que apliques lo que sabes en situaciones reales."
            ]
        },
        {
            "tag": "consultar_coordinador",
            "patterns": [
                "쯇uedo hablar con el coordinador?",
                "Contacto con el coordinador",
                "쮺on qui칠n resuelvo mis dudas?",
                "쮸 qui칠n le pregunto sobre la carrera?"
            ],
            "responses": [
                "Claro, el coordinador acad칠mico es la persona ideal para responder dudas espec칤ficas sobre la carrera. Puedes contactarlo por correo o en su horario de oficina.",
                "Tambi칠n puedes asistir a sesiones informativas o agendar una cita para una charla personalizada."
            ]
        },
        {
            "tag": "agradecimiento",
            "patterns": ["Gracias", "Muchas gracias", "Te lo agradezco", "Muy amable", "Excelente ayuda"],
            "responses": ["De nada, 춰estoy para ayudarte!", "Es un placer poder asistirte.", "No hay de qu칠, si necesitas algo m치s."]
        },
        {
            "tag": "despedida",
            "patterns": ["Adi칩s", "Hasta luego", "Nos vemos", "Chao", "Bye", "Hasta pronto", "Me despido"],
            "responses": ["춰Hasta luego! Fue un placer ayudarte.", "Adi칩s, 춰que tengas un buen d칤a!", "춰Nos vemos pronto! Mucho 칠xito en tus estudios."]
        },
        {
            "tag": "no_entendido",
            "patterns": [],
            "responses": ["No entiendo tu pregunta. 쯇uedes reformularla?", "Disculpa, no comprendo bien. Intenta decirlo de otra manera.", "쯇odr칤as ser m치s espec칤fico con tu pregunta sobre Ingenier칤a en Inform치tica?"]
        }
    ]
}
"""

# Crear archivo de intents
def crear_archivo_intents():
    """Crear archivo de intents.json en Drive"""
    intents_path = os.path.join(FILES_PATH, "intents.json")
    with open(intents_path, 'w', encoding='utf-8') as f:
        f.write(ejemplo_intents_informatica)
    print(f"Archivo intents.json creado en {intents_path}")
    return intents_path

# Verificar si existe el archivo de intents, si no, crearlo
intents_path = os.path.join(FILES_PATH, "intents.json")

# --- L칈NEA A칌ADIDA PARA FORZAR LA RECREACI칍N DEL ARCHIVO intents.json ---
# Esto ayuda a asegurar que el archivo JSON est칠 siempre bien formado con los nuevos intents.
# SI EST츼S SEGURO DE QUE TU intents.json EN DRIVE ES EL CORRECTO Y NO QUIERES QUE SE SOBRESCRIBA,
# PUEDES COMENTAR LAS SIGUIENTES 3 L칈NEAS.
if os.path.exists(intents_path):
    os.remove(intents_path)
    print(f"Antiguo intents.json eliminado de {intents_path}.")
# --- FIN DE LA L칈NEA A칌ADIDA ---

if not os.path.exists(intents_path):
    print("Creando archivo de intents...")
    intents_path = crear_archivo_intents()

# Definici칩n de la clase ChatbotEmpresarial
class ChatbotEmpresarial:
    def __init__(self, archivo_intents=None, carpeta_modelo=None, umbral_confianza=0.65):
        """Inicializa el chatbot empresarial

        Argumentos:
            archivo_intents: ruta al archivo JSON con intenciones y respuestas
            carpeta_modelo: directorio donde guardar/cargar el modelo
            umbral_confianza: confianza m칤nima para aceptar una predicci칩n
        """

        if archivo_intents is None:
            self.archivo_intents = os.path.join(FILES_PATH, "intents.json")
        else:
            self.archivo_intents = archivo_intents

        if carpeta_modelo is None:
            self.carpeta_modelo = FILES_PATH # Usamos la misma carpeta para modelos
        else:
            self.carpeta_modelo = carpeta_modelo

        self.umbral_confianza = umbral_confianza

        # Para almacenar datos procesados
        self.palabras = []
        self.clases = []
        self.documentos = []
        self.ignorar_caracteres = ['?', '', '!', '춰', '.', ',']
        self.stemmer = SnowballStemmer('spanish')
        self.intents = {}

        # Variables para el modelo
        self.modelo = None
        self.preparado = False

        # Informaci칩n contextual
        self.contexto = {}
        self.max_duracion_contexto = 5  # minutos

        # Crear directorio para el modelo si no existe
        os.makedirs(self.carpeta_modelo, exist_ok=True)

        # Cargar intents inmediatamente
        self.cargar_intents()

        # Intentar cargar un modelo existente
        try:
            modelo_path = os.path.join(self.carpeta_modelo, "modelo.h5")
            if os.path.exists(modelo_path):
                self.cargar_modelo()
            else:
                print("No se encontr칩 un modelo pre-entrenado. Ser치 necesario entrenar uno.")
        except Exception as e:
            print(f"Error al intentar cargar el modelo: {e}")
            print("Se entrenar치 un nuevo modelo.")
            self.preparado = False

    def cargar_intents(self):
        """Carga los intents desde el archivo JSON"""
        try:
            with open(self.archivo_intents, 'r', encoding='utf-8') as archivo:
                self.intents = json.load(archivo)
            print(f"Intents cargados: {len(self.intents['intents'])} intenciones")
            return True
        except Exception as e:
            print(f"Error al cargar intents desde {self.archivo_intents}: {e}")
            self.intents = {'intents': []} # Asegura que intents sea un diccionario con 'intents' vac칤o
            return False

    def preprocesar_datos(self):
        """Preprocesa los datos para entrenamiento"""
        # Verificar si ya tenemos intents cargados, si no, intentarlo
        if not self.intents or not self.intents['intents']:
            if not self.cargar_intents():
                print("No se pudieron cargar los intents. No se puede preprocesar.")
                return False

        # Resetear variables
        self.palabras = []
        self.clases = []
        self.documentos = []

        # Procesar cada intent
        for intent in self.intents['intents']:
            # Guardar la clase (tag) si no existe
            if intent['tag'] not in self.clases:
                self.clases.append(intent['tag'])

            # Procesar cada patr칩n de ejemplo
            for patron in intent['patterns']:
                # Tokenizar
                try:
                    # Intenta tokenizar la frase especificando el idioma
                    # Aqu칤 la validaci칩n se hace con NLTK directamente, no con try-except externo
                    tokens = nltk.word_tokenize(patron, language='spanish')
                except LookupError:
                    # Si el tokenizador en espa침ol no est치 disponible, intenta el predeterminado
                    print(f"Advertencia: No se pudo cargar el tokenizador en espa침ol para '{patron}', usando el predeterminado.")
                    try:
                        tokens = nltk.word_tokenize(patron)
                    except Exception as e:
                        # Fallback a tokenizaci칩n simple si hay otro error o NLTK falla totalmente
                        print(f"Error en tokenizaci칩n NLTK ({e}). Usando tokenizaci칩n simple con regex.")
                        tokens = re.findall(r'\b\w+\b', patron.lower())
                except Exception as e:
                    # Fallback a tokenizaci칩n simple para cualquier otro error
                    print(f"Error inesperado en tokenizaci칩n NLTK ({e}). Usando tokenizaci칩n simple con regex.")
                    tokens = re.findall(r'\b\w+\b', patron.lower())


                # A침adir a lista de palabras
                self.palabras.extend(tokens) # Usamos 'tokens' directamente

                # A침adir al documento (par de patr칩n tokenizado y tag)
                self.documentos.append((tokens, intent['tag'])) # Usamos 'tokens' directamente

        # Convertir a min칰sculas y eliminar duplicados y caracteres a ignorar
        self.palabras = [self.stemmer.stem(palabra.lower()) for palabra in self.palabras
                         if palabra not in self.ignorar_caracteres and palabra.strip() != '']

        # Eliminar duplicados y ordenar
        self.palabras = sorted(list(set(self.palabras)))
        self.clases = sorted(list(set(self.clases)))

        print(f"Vocabulario: {len(self.palabras)} palabras 칰nicas")
        print(f"Clases: {len(self.clases)} intenciones")
        print(f"Documentos: {len(self.documentos)} patrones de ejemplo")

        if not self.palabras or not self.clases:
            print("No se generaron palabras o clases. Revisa tu archivo intents.json.")
            return False
        return True

    def crear_datos_entrenamiento(self):
        """Crea los datos de entrenamiento para la red neuronal"""
        # Verificar si tenemos datos preprocesados
        if not self.palabras or not self.clases or not self.documentos:
            if not self.preprocesar_datos():
                raise ValueError("No se pudieron preprocesar los datos para el entrenamiento.")

        # Crear listas para entrenamiento
        datos_entrenamiento = []

        # Crear un array vac칤o para la salida (lleno de ceros)
        salida_vacia = [0] * len(self.clases)

        # Crear conjunto de bolsa de palabras para cada documento
        for doc in self.documentos:
            # Inicializar bolsa de palabras
            bolsa = []

            # Lista de palabras tokenizadas del patr칩n
            palabras_patron = doc[0]

            # Stemming de cada palabra
            palabras_patron = [self.stemmer.stem(palabra.lower()) for palabra in palabras_patron]

            # Crear bolsa de palabras: 1 si la palabra est치 en el patr칩n, 0 si no
            for palabra in self.palabras:
                bolsa.append(1) if palabra in palabras_patron else bolsa.append(0)

            # Copia de la salida (inicialmente todos 0)
            salida_fila = list(salida_vacia)

            # Poner 1 en la clase correspondiente
            salida_fila[self.clases.index(doc[1])] = 1

            # A침adir a los datos de entrenamiento
            datos_entrenamiento.append([bolsa, salida_fila])

        # Mezclar los datos
        random.shuffle(datos_entrenamiento)

        # Convertir a numpy array
        # Asegurarse de que las sublistas sean de tama침o uniforme
        x_train = np.array([item[0] for item in datos_entrenamiento])
        y_train = np.array([item[1] for item in datos_entrenamiento])

        return x_train, y_train

    def crear_modelo(self, capas_ocultas=[128, 64]):
        """Crea un modelo de red neuronal

        Argumentos:
            capas_ocultas: lista con el n칰mero de neuronas en cada capa oculta
        """

        # Verificar si tenemos datos
        if not self.palabras:
            self.preprocesar_datos()

        # Obtener dimensiones de entrada/salida
        input_shape = len(self.palabras)
        output_shape = len(self.clases)

        if input_shape == 0 or output_shape == 0:
            raise ValueError("No se pueden crear el modelo: dimensiones de entrada/salida son cero. Revisa tus intents.")

        # Crear modelo
        modelo = tf.keras.Sequential()

        # Capa de entrada
        modelo.add(tf.keras.layers.Dense(capas_ocultas[0], input_shape=(input_shape,), activation='relu'))
        modelo.add(tf.keras.layers.Dropout(0.5))

        # Capas ocultas adicionales
        for unidades in capas_ocultas[1:]:
            modelo.add(tf.keras.layers.Dense(unidades, activation='relu'))
            modelo.add(tf.keras.layers.Dropout(0.5))

        # Capa de salida
        modelo.add(tf.keras.layers.Dense(output_shape, activation='softmax'))

        # Compilar modelo
        modelo.compile(
            loss='categorical_crossentropy',
            optimizer='adam',
            metrics=['accuracy']
        )

        return modelo

    def entrenar_modelo(self, epochs=200, batch_size=5, verbose=1):
        """Entrena el modelo con los datos procesados

        Argumentos:
            epochs: n칰mero de 칠pocas de entrenamiento
            batch_size: tama침o del lote
            verbose: nivel de detalle durante el entrenamiento (0-2)
        """

        # Preparar datos
        try:
            x_train, y_train = self.crear_datos_entrenamiento()
        except ValueError as e:
            print(f"Error al crear datos de entrenamiento: {e}. No se puede entrenar el modelo.")
            return None # Retornar None para indicar que el entrenamiento fall칩

        if x_train.size == 0 or y_train.size == 0:
            print("Los datos de entrenamiento est치n vac칤os. No se puede entrenar el modelo.")
            return None

        # Crear modelo
        try:
            self.modelo = self.crear_modelo()
        except ValueError as e:
            print(f"Error al crear el modelo: {e}. No se puede entrenar.")
            return None

        # Entrenar modelo
        historial = self.modelo.fit(
            x_train, y_train,
            epochs=epochs,
            batch_size=batch_size,
            verbose=verbose
        )

        # Guardar modelo
        self.guardar_modelo()

        return historial

    def guardar_modelo(self):
        """Guarda el modelo entrenado y datos necesarios"""
        # Crear directorio si no existe
        os.makedirs(self.carpeta_modelo, exist_ok=True)

        # Guardar modelo
        self.modelo.save(os.path.join(self.carpeta_modelo, "modelo.h5"))

        # Guardar palabras
        with open(os.path.join(self.carpeta_modelo, "palabras.pkl"), 'wb') as archivo:
            pickle.dump(self.palabras, archivo)

        # Guardar clases
        with open(os.path.join(self.carpeta_modelo, "clases.pkl"), 'wb') as archivo:
            pickle.dump(self.clases, archivo)

        print(f"Modelo y datos guardados en {self.carpeta_modelo}")
        self.preparado = True

    def cargar_modelo(self):
        """Carga un modelo previamente entrenado"""
        try:
            # Cargar modelo
            modelo_path = os.path.join(self.carpeta_modelo, "modelo.h5")
            self.modelo = tf.keras.models.load_model(modelo_path)

            # Cargar palabras
            palabras_path = os.path.join(self.carpeta_modelo, "palabras.pkl")
            with open(palabras_path, 'rb') as archivo:
                self.palabras = pickle.load(archivo)

            # Cargar clases
            clases_path = os.path.join(self.carpeta_modelo, "clases.pkl")
            with open(clases_path, 'rb') as archivo:
                self.clases = pickle.load(archivo)

            print("Modelo y datos cargados exitosamente.")
            self.preparado = True
            return True
        except Exception as e:
            print(f"Error al cargar el modelo o datos: {e}")
            self.preparado = False
            return False

    def limpiar_frase(self, frase):
        """Limpia y tokeniza una frase de entrada
        Argumentos:
            frase: texto de entrada para procesar
        """
        try:
            # Intenta tokenizar la frase especificando el idioma espa침ol
            tokens = nltk.word_tokenize(frase, language='spanish')
        except LookupError:
            # Si el tokenizador en espa침ol no est치 disponible, intentar el predeterminado
            # print("Advertencia: No se pudo cargar el tokenizador en espa침ol, usando el predeterminado.")
            try:
                tokens = nltk.word_tokenize(frase)
            except Exception as e:
                # Fallback a tokenizaci칩n simple si hay otro error o NLTK falla totalmente
                print(f"Error en tokenizaci칩n NLTK ({e}). Usando tokenizaci칩n simple con regex.")
                tokens = re.findall(r'\b\w+\b', frase.lower())
        except Exception as e:
            # Fallback a tokenizaci칩n simple para cualquier otro error
            print(f"Error inesperado en tokenizaci칩n NLTK ({e}). Usando tokenizaci칩n simple con regex.")
            tokens = re.findall(r'\b\w+\b', frase.lower())

        # Stemming de cada palabra y eliminaci칩n de caracteres a ignorar
        tokens = [self.stemmer.stem(palabra.lower()) for palabra in tokens
                  if palabra not in self.ignorar_caracteres and palabra.strip() != '']
        return tokens

    def crear_bolsa_palabras(self, frase):
        """Crea una bolsa de palabras a partir de una frase

        Argumentos:
            frase: texto de entrada para convertir a bolsa de palabras
        """
        # Tokenizar y limpiar la frase
        tokens = self.limpiar_frase(frase)

        # Crear bolsa de palabras
        bolsa = [0] * len(self.palabras)

        for token in tokens:
            for i, palabra in enumerate(self.palabras):
                if palabra == token:
                    bolsa[i] = 1
        return np.array([bolsa])

    def predecir_clase(self, frase):
        """Predice la clase (intent) de una frase

        Argumentos:
            frase: texto de entrada para clasificar
        """
        if not self.preparado or self.modelo is None:
            print("El modelo no est치 preparado. Cargue o entrene primero.")
            return []

        # Crear bolsa de palabras
        bolsa = self.crear_bolsa_palabras(frase)

        if bolsa.shape[1] != len(self.palabras):
            print(f"Error: El tama침o de la bolsa de palabras ({bolsa.shape[1]}) no coincide con el vocabulario ({len(self.palabras)}).")
            return [] # Retorna vac칤o si hay un problema con las dimensiones

        # Predecir
        resultado = self.modelo.predict(bolsa, verbose=0)[0] # verbose=0 para no mostrar logs de predicci칩n

        # Filtrar predicciones por umbral de confianza
        resultados = [[i, r] for i, r in enumerate(resultado) if r > self.umbral_confianza]

        # Ordenar por probabilidad
        resultados.sort(key=lambda x: x[1], reverse=True)

        # Convertir 칤ndices a clases y probabilidades
        return_list =[]
        for r in resultados:
            return_list.append({
                "intent": self.clases[r[0]],
                "probability": float(r[1])
            })
        return return_list

    def obtener_respuesta(self, intents_predichos, id_usuario="general"):
        """Obtiene una respuesta basada en la intenci칩n predicha

        Argumentos:
            intents_predichos: lista de intents predichos con probabilidades
            id_usuario: identificador del usuario para mantener contexto
        """
        # Si no hay predicciones v치lidas
        if not intents_predichos:
            # Fallback a un intent predefinido para cuando no se entienda nada
            for intent in self.intents['intents']:
                if intent['tag'] == "no_entendido":
                    return {
                        "respuesta": random.choice(intent['responses']),
                        "intent": "no_entendido",
                        "contexto": None
                    }
            return { # Si ni siquiera "no_entendido" est치 definido
                "respuesta": "No entiendo tu pregunta. 쯇uedes reformularla?",
                "intent": None,
                "contexto": None
            }

        # Obtener el intent con mayor probabilidad
        tag = intents_predichos[0]['intent']
        probabilidad = intents_predichos[0]['probability']

        # Verificar tiempo de contexto
        self.limpiar_contextos_antiguos()

        # Verificar si estamos en un contexto espec칤fico
        contexto_actual = None
        if id_usuario in self.contexto:
            contexto_actual = self.contexto[id_usuario]["contexto"]

        # Buscar la respuesta adecuada
        for intent in self.intents['intents']:
            if intent['tag'] == tag:
                # Verificar si el intent requiere contexto y si coincide con el actual
                if 'contexto_requerido' in intent and contexto_actual != intent['contexto_requerido']:
                    # Este intent requiere un contexto espec칤fico que no tenemos, buscar una respuesta alternativa o default
                    continue

                # Seleccionar una respuesta aleatoria
                respuesta = random.choice(intent['responses'])

                # Actualizar contexto si es necesario
                if 'contexto_establecido' in intent:
                    self.contexto[id_usuario] = {
                        "contexto": intent['contexto_establecido'],
                        "tiempo": datetime.datetime.now()
                    }
                else:
                    # Limpiar contexto si no se establece uno nuevo (o si el intent no lo requiere)
                    if id_usuario in self.contexto:
                        del self.contexto[id_usuario]

                return {
                    "respuesta": respuesta,
                    "intent": tag,
                    "probabilidad": probabilidad,
                    "contexto": self.contexto.get(id_usuario, {}).get("contexto", None)
                }

        # Si llegamos aqu칤, significa que el intent predicho requer칤a un contexto que no se cumpli칩,
        # o que la intenci칩n predicha no tiene respuestas para el contexto actual,
        # o que no se encontr칩 el tag. En este caso, usamos el intent "no_entendido" si existe.
        for intent in self.intents['intents']:
            if intent['tag'] == "no_entendido":
                return {
                    "respuesta": random.choice(intent['responses']),
                    "intent": "no_entendido",
                    "contexto": None
                }
        return {
            "respuesta": "No puedo responder a eso en este momento o necesito m치s informaci칩n. 쯇odr칤as ser m치s espec칤fico?",
            "intent": tag, # A칰n reportamos el intent que se intent칩
            "probabilidad": probabilidad,
            "contexto": contexto_actual
        }

    def limpiar_contextos_antiguos(self):
        """Elimina contextos antiguos que hayan expirado"""
        tiempo_actual = datetime.datetime.now()
        usuarios_a_eliminar = []

        for id_usuario, datos_contexto in self.contexto.items():
            tiempo_contexto = datos_contexto["tiempo"]
            duracion = (tiempo_actual - tiempo_contexto).total_seconds() / 60  # en minutos

            if duracion > self.max_duracion_contexto:
                usuarios_a_eliminar.append(id_usuario)

        for id_usuario in usuarios_a_eliminar:
            del self.contexto[id_usuario]

    def get_respuesta(self, mensaje, id_usuario="general"):
        """M칠todo principal para obtener una respuesta a un mensaje

        Argumentos:
            mensaje: texto del usuario
            id_usuario: identificador del usuario
        """
        # Asegurarse de que el modelo est칠 listo
        if not self.preparado:
            print("El chatbot no est치 preparado. Intentando cargar o entrenar el modelo...")
            try:
                # Intentar cargar un modelo existente
                if not self.cargar_modelo():
                    # Si no hay modelo, entrenar uno nuevo
                    print("No se encontr칩 un modelo existente o hubo un error al cargarlo. Entrenando nuevo modelo...")
                    if self.preprocesar_datos(): # Asegurarse de preprocesar antes de entrenar
                        self.entrenar_modelo(epochs=300, verbose=1) # Aumentado a 300 칠pocas
                    else:
                        return {
                            "respuesta": "Error: No se pudieron preparar los datos para entrenar el chatbot.",
                            "error": True
                        }
                if not self.preparado: # Si despu칠s de intentar cargar/entrenar el modelo sigue sin estar preparado
                    return {
                        "respuesta": "Error: El chatbot no est치 listo para responder. Por favor, revisa la configuraci칩n y los logs.",
                        "error": True
                    }
            except Exception as e:
                return {
                    "respuesta": f"Error cr칤tico al preparar el chatbot: {str(e)}. Por favor, int칠ntalo de nuevo.",
                    "error": True
                }

        # Predecir la clase (intent)
        intents = self.predecir_clase(mensaje)

        # Obtener respuesta
        return self.obtener_respuesta(intents, id_usuario)

# Funci칩n para crear una interfaz de usuario en Colab
def crear_interfaz_chatbot():
    # Crear instancia del chatbot
    chatbot = ChatbotEmpresarial()

    # Preparar el chatbot si es necesario
    if not chatbot.preparado:
        print("Preparando el chatbot para la primera vez (puede tomar unos minutos)...")
        try:
            if not chatbot.preprocesar_datos():
                print("No se pudieron preprocesar los datos. Revisar intents.json.")
                return None, None # Indica que no se pudo inicializar

            if not chatbot.cargar_modelo():
                    print("No se encontr칩 un modelo existente. Entrenando nuevo modelo...")
                    chatbot.entrenar_modelo(epochs=300, verbose=1) # Aumentado a 300 칠pocas
        except Exception as e:
            print(f"Error cr칤tico al preparar el chatbot: {e}")
            return None, None # Indica que no se pudo inicializar

    # Crear ID de usuario
    id_usuario = f"user_{random.randint(1000, 9999)}"

    # Crear widgets para la interfaz
    header = widgets.HTML(value="<h2 style='text-align:center; color:#0078d7;'>Asistente Virtual de Ingenier칤a en Inform치tica</h2>")

    # 츼rea de chat
    chat_output_area = widgets.Output(
        layout=widgets.Layout(
            border='1px solid lightgray',
            height='300px',
            overflow_y='auto',
            background='#f5f8fa',
            padding='10px',
            border_radius='5px'
        )
    )

    # Mensaje inicial del bot
    with chat_output_area:
        # Aqu칤 el color de letra para el mensaje inicial del bot
        display(HTML(
            "<div style='background-color:#ECECEC; padding:10px; border-radius:10px; margin-bottom:10px; max-width:70%; color: #000;'>" # COLOR NEGRO
            "춰Hola! Soy el bot de Ingenier칤a en Inform치tica 游뱄游눹 Estoy aqu칤 para responder tus preguntas sobre la carrera. 쯈u칠 te gustar칤a saber?"
            "</div>"
        ))
        # JavaScript para el scroll
        display(Javascript('''
            var chatContainer = document.querySelector("#%s div"); // Selecciona el div de contenido real dentro del Output
            if (chatContainer) {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
        ''' % chat_output_area.comm.target_name))


    # Entrada de texto y bot칩n
    text_input = widgets.Text(
        placeholder='Escribe tu mensaje aqu칤...',
        layout=widgets.Layout(width='80%')
    )

    send_button = widgets.Button(
        description='Enviar',
        button_style='primary',
        layout=widgets.Layout(width='18%'
    ))

    # Funci칩n para manejar el env칤o de mensajes
    def on_send_button_clicked(b):
        mensaje = text_input.value
        if not mensaje.strip():
            return

        # Limpiar entrada
        text_input.value = ''

        # Mostrar mensaje del usuario
        with chat_output_area:
            # Aqu칤 el color de letra para el mensaje del usuario
            display(HTML(
                f"<div style='background-color:#DCF8C6; padding:10px; border-radius:10px; margin-bottom:10px; max-width:70%; margin-left:30%; color: #000;'>{mensaje}</div>" # COLOR NEGRO
            ))
            # JavaScript para el scroll
            display(Javascript('''
                var chatContainer = document.querySelector("#%s div");
                if (chatContainer) {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            ''' % chat_output_area.comm.target_name))


        # Obtener respuesta del chatbot
        resultado = chatbot.get_respuesta(mensaje, id_usuario)

        # Simular tiempo de respuesta para una experiencia m치s natural
        # Esto podr칤a ayudar a que la interfaz no se sobrecargue con demasiadas actualizaciones r치pidas
        time.sleep(0.5)

        # Agregar respuesta del chatbot
        with chat_output_area:
            # Aqu칤 el color de letra para el mensaje del bot
            display(HTML(
                f"<div style='background-color:#ECECEC; padding:10px; border-radius:10px; margin-bottom:10px; max-width:70%; color: #000;'>{resultado['respuesta']}</div>" # COLOR NEGRO
            ))
            # JavaScript para el scroll
            display(Javascript('''
                var chatContainer = document.querySelector("#%s div");
                if (chatContainer) {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            ''' % chat_output_area.comm.target_name))


    # Conectar eventos
    send_button.on_click(on_send_button_clicked)

    # Conectar tecla Enter
    def handle_enter(widget):
        on_send_button_clicked(None)

    text_input.on_submit(handle_enter)

    # Crear layout de entrada
    input_layout = widgets.HBox([text_input, send_button])

    # Crear layout principal
    main_layout = widgets.VBox([header, chat_output_area, input_layout])

    # Mostrar interfaz
    display(main_layout)

    # Enfocar entrada de texto
    display(Javascript('document.querySelector("input").focus();'))

    return chatbot, id_usuario

# Funci칩n principal
def main():
    print("Inicializando Chatbot Empresarial...")

    # Crear interfaz del chatbot
    print("Creando interfaz del chatbot...")
    chatbot, id_usuario = crear_interfaz_chatbot()

    if chatbot and id_usuario:
        print(f"Chatbot inicializado con ID de usuario: {id_usuario}")
        print("Ahora puedes interactuar con el chatbot.")
    else:
        print("Fallo al inicializar el chatbot. Revisa los mensajes de error anteriores.")

# Ejecutar el programa
if __name__ == "__main__":
    main()
